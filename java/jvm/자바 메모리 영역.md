### 2025-02-03

#### 자바 메모리 영역

1. 런타임 데이터 영역

1.1. 프로그램 카운터(pc) 레지스터
- 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트 코드 줄 번호 표시기' 이다. JVM 바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다.
JVM 에서 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 떄문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게된다.
따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 그래서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다.

1.2. 자바 가상 머신 스택
- 프로그램 카운터처럼 자바 가상 머신 스택 영역도 독립된 영역을 가지며, 연결된 스레드와의 생성/삭제 시기가 일치한다.
자바 메서드를 실행하는 스레드의 메모리 모델을 설명해주는 영역으로, 각 메서드가 호출될 때마다 JVM은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다.
그런 다음 스택 프레임을 가상 머신 스택에 push 하고, 메서드가 끝나면 pop 하는 일을 반복한다.

- 스택 메모리 영역에서는 두 가지 오류가 발생할 수 있는데 하나는 StackOverFlowError 이고, 다른 하나는 OutOfMemoryError 이다.
스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크다면 StackOverFlowError가 발생한다. 
스택 용량을 동적으로 확장할 수 있는 JVM에서는 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError를 발생시킨다.

1.3. 네이티브 메서드 스택
- 자바 가상 머신 스택과 매우 비슷한 역할을 하나 가상 머신 스택은 자바 메서드를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다.
(여기서 네이티브 메서드는 Java가 아닌 다른 언어(주로 C/C++)로 작성된 메서드를 말한다.)

- 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 있다.

1.4. 자바 힙
- 자바 어플리케이션이 사용할 수 있는 가장 큰 메모리이다. 모든 스레드가 공유하는 영역으로, 가상 머신이 구동될 때 만들어진다.
자바 언어에서 생성된 거의 모든 객체 인스턴스가 이 영역에 할당된다.

- 자바 힙은 가비지 컬렉터가 관리하는 메모리 영역이기 때문에 GC 힙이라고 불리기도 한다.

- 메모리 할당 관점에서 자바 힙은 모든 스레드가 공유를 하고, 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러개로 나뉘게 된다.
이렇게 여러개로 나누는 이유는 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.

- 자바 힙은 크기를 고정할 수도 있고, 확장할 수도 있다. (-Xmx, -Xms 매개 변수로 변경 가능)
새로운 인스턴스에 할당해 줄 힙 공간이 부족하고 더는 힙을 확장할 수 없는 경우에는 OutOfMemoryError 를 던지게 된다.

1.5. 메서드 영역
- 메서드 영역도 자바 힙처럼 모든 스레드가 공유를 하는 영역이다. 메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수, 그리고 JIT 컴파일러가 컴파일한 코드 캐시등을 저장하는데 이용된다.
자바 힙과 구분하기 위해 논힙(non-heap) 이라고 부르기도 한다.

- JDK7 에 이르러서 영구 세대에서 관리하던 문자열 상수와 정적 변수 등의 정보를 자바 힙으로 옮겼다. JDK8 에서는 영구 세대에 남아있던 모든 데이터를 메타스페이스로 옮기게된다.

- 메서드 영역에서 회수할 대상은 상수 풀과 타입 정보라서 회수 효과는 상대적으로 매우 작지만, 그렇다고 메서드 영역을 회수하지 않아서 메모리가 누수되는 버그가 발생할 수도 있다.

1.6. 런타임 상수 풀
- 런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.
가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장한다.

- 클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 특징은 동적이라는 점이다. 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다.

- 런타임 상수 풀은 메서드 영역에 속하므로 자연스럽게 메서드 영역을 넘어서까지 확장될 수는 없다. 상수 풀의 공간이 부족하면 OutOfMemoryError 를 던지게 된다.

1.7. 다이럭트 메모리
- 다이렉트 메모리는 가상 머신 런타임에 속하지 않으며, 자바 가상 머신 명세에 정의된 영역도 아니다. 하지만 자주 쓰이고, OutOfMemoryError의 원인이 되기도 하는 부분이다.

- JDK1.4 에서 도입된 NIO 가 직접적으로 시스템 메모리(네이티브 힙)에 메모리를 할당하면서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 되도록 만들어 주어서 성능을 개선했다.
하지만 시스템 메모리도 결국 메모리이기 때문에, 메모리 용량이 정해져있다. 또한 해당 메모리가 가득 찼는데 또 주소를 할당하고자 하면 OutOfMemoryError가 발생하게 된다.
