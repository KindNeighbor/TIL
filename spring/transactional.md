### 2024-12-07

#### @Transactional 과 롤백 테스트

<br>

@Transactional 을 테스트 클래스에 적용시키면, 단위 테스트 진행 후 DB 에 넣었던 데이터는 롤백을 시켜준다.

근데 롤백 테스트를 해야하는 경우에는? 문제가 발생한다.

<br>

테스트 시나리오를 예시를 하나 들어보자

1. 매핑 추가/삭제 메소드가 존재하고, 각 매핑 프로세스 이후에는 API 를 호출하는 로직이 있다.

2. 만약에 매핑 프로세스는 성공을 했는데, API 호출 시 뭔가 에러가 발생하면 먼저 진행한 매핑 프로세스를 롤백한다.

3. 우선 매핑 추가 메소드를 호출해서 데이터를 DB 에 넣는다. 이때 API 호출은 성공하는것으로 한다.

4. 다음으로는 매핑 삭제 메소드를 호출하는데, 이때는 API 호출에 실패한다. 즉 매핑 삭제가 되어서 DB 에서 데이터를 삭제한 것을 롤백해야한다.

<br>

이렇게 테스트를 진행한다고 해보자. 우선 매핑 성공으로 DB 에 데이터가 들어갔으면, TestTransaction 을 통해서 commit 을 한다.

이후 매핑 삭제 메소드를 호출하고, 롤백까지 되어서 DB 에 데이터가 지워지지 않고 남아있다는 것을 확인하고 테스트가 끝날것이다.

그러면 테스트가 끝났으니 @Transactional 에 의해서 처음 매핑 추가로 넣은 데이터가 롤백이 되어야 하는데, 실제로는 그렇지 않다.

TestTransaction 을 통해서 commit 을 했기 때문이다.

<br>

그러면 TestTransaction 을 사용하지 않으면 어떻게 될까?

그럼 매핑 추가로 DB 에 데이터가 들어가고, 롤백테스트를 할 때 롤백 프로세스가 진행되면서 앞서 데이터를 넣은 부분까지 롤백된다.

왜냐하면 하나의 물리 트랜잭션으로 되어있기 때문이다. 하나의 물리 트랜잭션 안에서 논리 트랜잭션이 하나라도 롤백이 발생하면, 전체 트랜잭션이 롤백이 되니까 말이다.


결국 @Transactional 로는 롤백 테스트를 하기는 어렵다. 뭔가 @AfterEach 를 사용해서 테스트 이후에 할 후처리를 정해주거나,

테스트 메소드 내에서 직접 DB 데이터를 삭제하는 방법으로 롤백테스트를 진행해야한다.

@Transactional 은 롤백을 지원해서 테스트가 끝나면 이전과 같은 상황을 만들어주어서 편리하지만, 롤백테스트에서는 한계가 있다.
